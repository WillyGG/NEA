28 Dec: 
  - implemented counting AI interface
  - designed and started to implement probablility chances (bustchance blackjack chance etc)
  - Added search functionality and counting total number of cards in subtree functionality to imp ^

  - TODO: - implement maintainance of tree from within the tree class
	  - find a way to abstract away the post/pre/in order traversals
	  - Test the implementation of the bust chances

29 Dec:
    - completed lower level calc chance methods

    TODO:
        - Statistical analysis of chances to be used by CC AI - run through a lot of games and graph the empirical data
        - find a way to abstract away the post/pre/in order traversals
	    - Test the implementation of the bust chances
	    - UPDATE BUSTCHANCE TO INCLUDE EVERYTHING IN RIGHT SUBTREE, AND NODES ABOVE, IF TURNING NODE IS IN LEFT SUBTREE and do the same for the exceed dealer chance.
	       - Greater than and less than card counts, create a new tree out of each node? Too inefficient?

30 Dec:
    - completed high-level composite counting function.
    - created individual trees, with turning node as the root, if the turning node is on the left subtree, then count everything on the right of the root of this new subtree.

    TODO:
        - Statistical analysis of thresholds to be used by CC AI - run through a lot of games and graph the empirical data
        - find a way to abstract away the post/pre/in order traversals
	    - Test the implementation of all the chances
	    - Test the implementation of the card counting, and add a counting of less than or equal to the turning node
	    - Once behaviour is tested and is as intended, begin adding thresholds and implement in game behaviour then test these thresholds

02 Jan:
    - Tested and debugged:
        counting for root and nodes in right subtree, nodes for left subtree

    - Main bugs were with node comparison - sometimes i passed an integer, sometimes I passed a node, made the decrement method compatible for both
    - The way python makes references to variables - nodes in the main tree were being overwritten by nodes in the count tree. Fixed this by making new copies of the nodes (although inefficient)

03 Jan:
    - Tested node deletion due to decrementation

    TODO:
        - Alter blackjack game interface so that it does not create a new deck each time?
        - improve NN to include recurrent features, try different algorithms, then try to use counting AI as new features?

05 Jan:
    - changed blackjack to keep deck after each game, until empty
    - Changed the deck class so that it autoshuffles when it is empty.
    - Changed a tracker boolean variable to int which keeps track of which iteration the deck is on
    - Changed the blackjack game so that it does not create a new deck after each game.
    - Changed the getNode tree method into getNode (initial function) and getNode Traversal (recursive function)
    - Debugged the getNode Traversal (nonetype attribute error -> changed the order of checking at start of function to if none -> if == nodeValue)
    - Debugged chance calculating algo.s - checked if cannot or already bust/blackjack'd
    - Issue -> getting next node greater than turning node, when turning node is in left subtree. (cannot just get node on right, root and all of right subtree is larger)
    - ^ Debugged by getting calling getNode on next largest value (maybe implement a getNextNode function in BT or getPrevNode?)
    - Issue -> GT Turning node sometimes returns None

    TODO:
    - Package traversal functionality in a static class
    - Begin working on basic ifs and loops version
    - Comparison tool will be the MEAT of the marks in this paradigm


06 Jan:
    - Debugged the getNode recursive function to return the correct node rather than returning none.
    - Debugged the exceed dealer chance funciton ==> cannot just get the right node of the turning node, to find next node up, have to getNode seperately. Also calculated the turning node's value correctly (now gets value needed to EXCEED)
    - bug -> blackjack chance calculator still returns none sometimes??
    - bug?? -> exceedDlrNoBust sometimes returns a negative value

    - fixed blja and bust chances by correcting condition checks for already bust/blackjack/cannot
    - implemented first version of simple AI


    TODO:
    - find a way to adjust the maxcard if all the aces have been drawn
    - implement a way to check if the counting has to be reset during the game.
    - faking move the maintainence to the tree.

 08 Jan:
    - corrected return none bug, adjusted limits and conditions for already blackjack/bust, results in getting correct node
    - debugged getNodeTraverse by returning what the subtree recursive calls return.
    - First implementation of simple AI
        - Always hit if cannot go bust
        - Hit until above dealer, and until get close to going bust.

    TODO:
    - Calc chances returns chances above 1 and below 0 sometimes - logical tests
    - implement interface for simple AI
    - test simple ai
    - Start comparison tool designs
    - implement tests for behaviour --> Test Decrement, hit/stand, reset tree, adjust tree for royals + add ace functionality
    - implement a more nuanced behaviour for the decisions by the CCAI
    - Change the CCAI parameters to be personality parameters (eg aggression) and then calculate the thresholds based on this.
    - implement a sort for inputting nodes when building tree

   09 Jan:
   - debugged the logic of the CCAI (sometimes chances went above 1 or below 0)
    - Implemented the decsision making behaviour, with the chance thresholds
    - began designs for the BT Maintainence

   10 Jan:
    - Completed BTMaintainence psudocode and concept
    - Began implementing the actual code

    TODO:
    - Add a display tree structure function to display the structure of the binary tree.
    - Continue implementing the BST Maintainence
    - complete compare_ST_Traverse function

   15 Jan:
    - Complete BTMaintainence 1st 1st implementation
    - began concept and pseudocode for comparison tool

    TODO:
    - Test the compare_ST_Traverse and Get_Max_LST and Get_Min_RST functions
    - Implement an interface for the comparison tool, to be implemented by all the different AI

    Next -> Extend Blackjack to accomodate more than one player. -> split the blackjack class into hands and use compostition.

   19 Jan:
    - implemented Hand class
    - changed blackjack class to accommodate for hand class
        - changed: reset, init_deal, assess_hand (may not be needed), compare_hands, deal, hit, stand, display_game, end_game

    TODO:
    - TEST FAKING EVERYTHING
    - create a dealer child class
    - implement dealer changes
    - pass in the players to the blackjack class

   20 Jan:
    - added a dealer child class (check if its functionality is in the right place)
    - players are now passed into the blackjack class
    - Added circular Queue
    - fully implemented circular queue, and updated all methods to work with it
    - game now contains ciruclar queue of players:
        - everytime hit or stand is called (blackjack class) the next player to play is popped and operation is taken out on that player
    - added a "whoseTurnisItFunction"

    TODO:
    - test faking everything!
    - add a player class which will contain player name (so it is not contained in hand) and get info about that player from DB
    - update blackjack to operate with Players, rather than hands? or find a way to implement it

  21 Jan:
    - bj manual test with 2 players + dealer
    - fully debugged -> mostly bugs with methods not updated after player_queue still using player dict

  22 Jan:
    - added num elements in queue attribute to circular queue
    - First implementation of display tree structure, works for 6 -> root, insert(5), insert(7)

    TODO:
    - Complete degbugging this for the full tree in use atm.


  23 Jan:
    - Decided display structure method was not worth it
    - Finalising on maintaining tree structure from binary tree class
    - refactored node equivalence method, by allowing comparison between ints and nodes, by comparing the node value to the int.
    - implemented get parent method
    - refactored insert method to prevent repeated node insertions
    - completed first maintainence implementation (UNTESTED)
    - rewrote the insert method to actually work?? not sure what happened to it
    - tested get_min_RST and get_max_LST (maybe try one or two more cases?)
    - tested binary tree maintainence - IT WUUURKS?? (check the structure)
    - binary tree maint. works for rst
    - got binary tree to work for lst too (abs(left - right) >= 2, rather than abs(left - right) == 2)

    TODO:
    - abstract swapping away into method
    - test the maintainence methods
    - traversals - *args, if len(args) == 0 then parent = self._root
    - make the maintainence methods actual good code
    - remove num elements from circular queue

  28 Jan:
    - abstracted away the swapping
    - started working on recurrent nn ai

  29 Jan:
    - implemented prim_net, target_net, exp_buffer, bj_interface, training_interface

  01 Feb:
    - filled up most of the main training loop
    - implmented train policy action

    TODO:
    - implement a policy package
    - fix up the step reward
    - implement process action method
    - implement update network method
    - implement save model method
    - implement with tf.session() as sess and the bits below it
    - implment end of game processing for the training
    - update this TODO xd

    - Test the current implmentation

  03 Feb:
    - Implemented the training class completely -> need to finish blja interface class impl
    - modified game state getting (only two features atm)
    - modified step reward

    TODO:
    - modify public attributes to protected
    - make hand id hashed
    - figure out who to do the end game reward

 04 Feb:
    - Got rid of num_elements from circular queue, cleaned up blackjack code a lil

 05 Feb:
    - updated reward values
        - winner and loss rewards if absolute winner / loser
        - hit reward: normal reward if not bust, else: loss cost
        - stand: normal reward if part of current winners, else: loss cost

    - began testing training class
    TODO:
    - figure out why the nn outputs 4 actions instead of 2
    
 08 Feb:
    TODO:
    - Change hand class to separate file with children of blackjack and poker hands


 09 Feb:
    - Complted training code
    - began writing performance testing code

    TODO:
    - Fix the win detection / find out if the NN is straight losing every game.

 12 Feb:
    - Fixed issue of resetting hands not occurring properly - forgetting to update attributes after changing them from private to protected
    - fixed issue of 0% winrrate - change game reset to manual, and winners now detected
    - parameters all messed up - fixing
    - fixed state of game and samples being passed incorrectly
    - completed normal training stage: NN vs Dealer

    TODO:
    - NN agent winrrate is absolute dog
    - FIX THE PARAMETERS DICTIONARY
    - DO ALGO DETERMINING BEST PARAMS
    - extend for more policies and make ready for comparison tool
    - change features to take calculations of CCAI
    - adapt rewards for different outcomes

 13 Feb:
    - Adjusted file architecture
    - Adjusted the loss reward, didnt change much
    - Started working on loosely coupled traversal methods
    - started implementing traversal static methods - need to figure out the cases

    -FIXED EVEYRTIHNG WHICH BROKE DUE TO THIS UPDATING

    TODO:
    - FIX THE MAINTAINENCE / insertion <- DONE

 14 Feb:
    - Updated CCAI to work with new blackjack class, and updated it for the records to work correctly with royals and aces
    - Updated the maintainence function to use -1 instead of False as a flag -> never use False as the flag

    TODO:
    - fix the counts, sometimes this goes above 100% or below 0%
    - Fix the calc Chances -> somtimes run time err

 15 Feb:
    - updated delete method to be more clean
    - addded edge cases for calculations when specific nodes are no longer present in the tree
    - added edge case to update deck half way through calculations
    - the delete changes have messed up the insertion or the maintainence - fix this <- fixed
    - do not put maintain subtrees in delete, either do that or have a non maintain delete -> just call the maintain manually after deletion

    TODO:

 16 Feb:
    - Adjusted exceedDealerNoBust -> ExceedWinningPlayer
    - Added Already Exceeding
    - Seperated the CCAI design -> split into (CC, AI) to allow CC functionality use for NN
    - changed the CC so now have to decrement and unpack game state outstide of CC class
    - implemented the CC Interface
    - debugged Card Count LT -> was just counting all nodes in subtree -> now counts nodes just LT, by passing in the left subtree to total count method

 17 Feb:
    - realised that the counting algorithm for nodes GTET does not work by just using subtree associated with the turning node
    - requires full traversal -> either go back to the tmp tree class, or full traversal of tree
    - decided full traversal -> implemented, bug: if it is a full traversal then need to take off aces -> debugged
    - fully debugged counting issue

 19 Feb:
    - changed the number of features on the NN to include the CC chances => NO WRONG METHOD WAS CALLED
    - winrate goes up to about 46
    - started on separated CCAI class
    - Oddly enough the winnrate stays about the same, when put in the right class
    - went up to 50% for one run

    TODO:
    - make base player class which all the agents can inherit from to get basic things like names
    - get all new cards from game to decrement cards -> DONE FOR NN

 20 Feb:
    - completed converting CC_AI
    - started converting NN to a class, now building interface which allows for different interactions for the comparison tool
    - began working on comparison tool
    - completed comparison tool class design

    TODO:
    - implement comparison tool
    - implement play style detection algorithm
    - convert aggression settings to a number scale, rather than discrete values